#include "TXLib.h"
#include <cmath>
#include <iostream>

const double dt = 0.1;

struct Ball {

	double  x = 6,
		y = 6,
		r = 5,
		Vx = 10,
		Vy = 10,
		red = 144,
		green = 0,
		blue = 0;

};

bool Is_Collide_of_Balls(const Ball& ball1, const Ball& ball2) {

	if (sqrt(pow(ball1.x - ball2.x, 2) + pow(ball1.y - ball2.y, 2)) <= ball1.r + ball2.r) {
		float V_relative_1_to_2_X = ball1.Vx - ball2.Vx;
		float V_relative_1_to_2_Y = ball1.Vy - ball2.Vy;

		if (((ball2.x - ball1.x) * V_relative_1_to_2_X > 0) && ((ball2.y - ball1.y) * V_relative_1_to_2_Y > 0)) {

			return true;
		}
		else if ((ball2.x - ball1.x) * V_relative_1_to_2_X > 0) {
	
			return true;
			
		}
		else if ((ball2.y - ball1.y) * V_relative_1_to_2_Y > 0) {
			
			return true;
			
		}

	}

	return false;
}
void Collide_of_Balls(Ball& ball1, Ball& ball2) {

	double sin = -1;
	double cos = 0;

	if (Is_Collide_of_Balls(ball1, ball2)) {
		if (ball1.x == ball2.x) {
			if (ball1.y < ball2.y) {
				sin = 1;
				cos = 0;
			}
			else {
				sin = -1;
				cos = 0;
			}
		}
		else {
			double k = (ball2.y - ball1.y) / (ball2.x - ball1.x);
			sin = k / (sqrt(pow(k, 2) + 1));
			cos = 1 / (sqrt(pow(k, 2) + 1));
		}

		// зададим через матрицу перехода свзять координат в разных СО

		double V_trans_before_hitting_1_ball = cos * ball1.Vx + sin * ball1.Vy;
		double V_normal_before_hitting_1_ball = (-1) * sin * ball1.Vx + cos * ball1.Vy;

		double V_trans_before_hitting_2_ball = cos * ball2.Vx + sin * ball2.Vy;
		double V_normal_before_hitting_2_ball = (-1) * sin * ball2.Vx + cos * ball2.Vy;

		// выразил скорости в новой СК , теперь поменяем тангенциальные составляющие

		double tmp = V_trans_before_hitting_2_ball;

		V_trans_before_hitting_2_ball = V_trans_before_hitting_1_ball;
		V_trans_before_hitting_1_ball = tmp;

		// теперь вернем эти координаты в старую систему координат 

		double V_x_1_ball_after_hitting = cos * V_trans_before_hitting_1_ball - sin * V_normal_before_hitting_1_ball;
		double V_y_1_ball_after_hitting = sin * V_trans_before_hitting_1_ball + cos * V_normal_before_hitting_1_ball;

		double V_x_2_ball_after_hitting = cos * V_trans_before_hitting_2_ball - sin * V_normal_before_hitting_2_ball;
		double V_y_2_ball_after_hitting = sin * V_trans_before_hitting_2_ball + cos * V_normal_before_hitting_2_ball;

		// теперь поменяем значения соответствующих переменных

		ball1.Vx = V_x_1_ball_after_hitting;
		ball1.Vy = V_y_1_ball_after_hitting;

		ball2.Vx = V_x_2_ball_after_hitting;
		ball2.Vy = V_y_2_ball_after_hitting;
	}
}
void Collide_of_All_Balls(Ball* balls) {

	for (int i = 0; i < 50; ++i) {

		for (int j = 0; j < 50; ++j) {
			if (i != j) {
				Collide_of_Balls(balls[i], balls[j]);
			}
		}
	}
}

void DrawBall(const Ball& ball) {

	for (double k = ball.r; k > 0; --k) {

		auto rgb = RGB(ball.red * sqrt((1 - pow(k / ball.r, 2))), ball.green * sqrt((1 - pow(k / ball.r, 2))), ball.blue * sqrt((1 - pow(k / ball.r, 2))));

		txSetFillColor(rgb);
		txSetColor(rgb);
		txCircle(ball.x, ball.y, k);

	}
}
void DrawAllBalls(Ball* balls) {
	for (int i = 0; i < 50; ++i) {

		DrawBall(balls[i]);
	}

}
void MoveBall(Ball& ball) {


	if (ball.y > 600 - ball.r && ball.Vy > 0 || ball.y < ball.r && ball.Vy < 0) {

		ball.Vy = (-1) * ball.Vy;

	}
	if (ball.x > 800 - ball.r && ball.Vx > 0 || ball.x < ball.r && ball.Vx < 0) {

		ball.Vx = (-1) * ball.Vx;

	}

	ball.x += ball.Vx * dt;
	ball.y += ball.Vy * dt;
}
void MoveAllBalls(Ball* balls) {

	for (int i = 0; i < 50; ++i) {
		MoveBall(balls[i]);
	}
}

int main() {

	setlocale(LC_ALL, "Russian");

	txCreateWindow(800, 600);

	Ball* balls = new Ball[50];

	for (int i = 0; i < 50; ++i) {

		balls[i].r = 10;
		balls[i].x = rand()%800;
		balls[i].y = rand()%600;
		balls[i].Vx = rand()%20;
		balls[i].Vy = rand()%20;
	}

	for (;;) {

		txClear();

		txBegin();

		DrawAllBalls(balls);
		MoveAllBalls(balls);
		Collide_of_All_Balls(balls);

		txSetFillColor(RGB(0, 0, 0));

		txEnd();
	}
	delete[] balls;
	return 0;
}
