#include "TXLib.h"
#include <vector>
#include <cmath>
#include <iostream>


const double dt = 0.1;

struct Ball {

	double  x = 6,
			y = 6,
			r = 5,
			Vx = 10,
			Vy = 10,
			red = 144,
			green = 0,
			blue = 0;

};
void Collision_of_Balls(Ball& ball1, Ball& ball2) {

	double k = (ball2.y - ball1.y) / (ball2.x - ball1.x);

	double sin = k / (sqrt(pow(k, 2) + 1));
	double cos = 1 / (sqrt(pow(k, 2) + 1));

	// зададим через матрицу перехода свзять координат в разных СО

	double V_trans_before_hitting_1_ball = cos * ball1.Vx + sin * ball1.Vy;
	double V_normal_before_hitting_1_ball = (-1) * sin * ball1.Vx + cos * ball1.Vy;

	double V_trans_before_hitting_2_ball = cos * ball2.Vx + sin * ball2.Vy;
	double V_normal_before_hitting_2_ball = (-1) * sin * ball2.Vx + cos * ball2.Vy;

	// выразил скорости в новой СК , теперь поменяем тангенциальные составляющие

	double tmp = V_trans_before_hitting_2_ball;

	V_trans_before_hitting_2_ball = V_trans_before_hitting_1_ball;
	V_trans_before_hitting_1_ball = tmp;

	// теперь вернем эти координаты в старую систему координат 

	double V_x_1_ball_after_hitting = cos * V_trans_before_hitting_1_ball - sin * V_normal_before_hitting_1_ball;
	double V_y_1_ball_after_hitting = sin * V_trans_before_hitting_1_ball + cos * V_normal_before_hitting_1_ball;

	double V_x_2_ball_after_hitting = cos * V_trans_before_hitting_2_ball - sin * V_normal_before_hitting_2_ball;
	double V_y_2_ball_after_hitting = sin * V_trans_before_hitting_2_ball + cos * V_normal_before_hitting_2_ball;

	// теперь поменяем значения соответствующих переменных

	ball1.Vx = V_x_1_ball_after_hitting;
	ball1.Vy = V_y_1_ball_after_hitting;

	ball2.Vx = V_x_2_ball_after_hitting;
	ball2.Vy = V_y_2_ball_after_hitting;

}


void DrawBall(const Ball& ball) {

	for (double k = ball.r; k > 0; --k) {

		auto rgb = RGB(ball.red * sqrt((1 - pow(k / ball.r, 2))), ball.green * sqrt((1 - pow(k / ball.r, 2))), ball.blue * sqrt((1 - pow(k / ball.r, 2))));

		txSetFillColor(rgb);
		txSetColor(rgb);
		txCircle(ball.x, ball.y, k);

	}
}
void DrawAllBalls(Ball* balls ) {
	for (int i = 0; i < 100; ++i) {

		DrawBall(balls[i]);
	}

}
void MoveBall(Ball& ball1, Ball& ball2) {

	if (ball2.y > 600 - ball2.r && ball2.Vy > 0 || ball2.y < ball2.r && ball2.Vy < 0) {

		ball2.Vy = (-1) * ball2.Vy;

	}
	if (ball2.x > 800 - ball2.r && ball2.Vx > 0 || ball2.x < ball2.r && ball2.Vx < 0) {

		ball2.Vx = (-1) * ball2.Vx;

	}

	if (ball1.y > 600 - ball1.r && ball1.Vy > 0 || ball1.y < ball1.r && ball1.Vy < 0) {

		ball1.Vy = (-1) * ball1.Vy;

	}
	if (ball1.x > 800 - ball1.r && ball1.Vx > 0 || ball1.x < ball1.r && ball1.Vx < 0) {

		ball1.Vx = (-1) * ball1.Vx;

	}


	if (sqrt(pow(ball1.x - ball2.x, 2) + pow(ball1.y - ball2.y, 2)) < ball1.r + ball2.r) {

		Collision_of_Balls(ball1, ball2);

	}

	ball1.x += ball1.Vx * dt;
	ball1.y += ball1.Vy * dt;

	ball2.x += ball2.Vx * dt;
	ball2.y += ball2.Vy * dt;
}
void MoveAllBalls(Ball* balls) {
	for (int i = 0; i < 100; ++i) {
		for (int j = 0; j < 100 && j != i && j>i ; ++j) {

			MoveBall(balls[i], balls[j]);

		}
	}

}



int main() {

	setlocale(LC_ALL, "Russian");

	txCreateWindow(800, 600);
	
	Ball* balls = new Ball[100];
	
	int x = 15;
	int y = 15;
	for (int i = 0; i < 100;++i ) {

		balls[i].r = 5;

		if (x > 300) {
			y += 30;
			x = 15;
		}
		balls[i].x = x;
		balls[i].y = y;
		balls[i].Vx = 10;
		balls[i].Vy = 10;
		x += 30;

	}

	for (;;) {

		txClear();

		
		txBegin();

		DrawAllBalls(balls);
		MoveAllBalls(balls);
		std::cout << balls[3].x << std::endl;

		txSetFillColor(RGB(0, 0, 0));

		txEnd();
		txSleep(0.02);
	}
	delete[] balls;
	return 0;
}
